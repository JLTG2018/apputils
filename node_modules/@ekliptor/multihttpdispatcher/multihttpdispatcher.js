var util = require('util');
var multiparty = require('multiparty')

var HttpDispatcher = function() {
    //> added more methods to avoid crash
    // TODO this is not as specified for the HTTP protocol. HEAD requests will now return nothing because we don't add a listener
	this.listeners = { get: [ ], post: [ ], put: [ ], head: [ ], delete: [ ], trace: [ ], connect: [ ] };

	this.filters = { before: [ ], after: [ ] };
	this.errorListener = function(req, res) { 
		res.writeHead(404);
		res.end();
	}
	this.staticFolderPrefix = '/static';
	this.staticDirname;
	this.staticHeaders = []; //Ekliptor> cache headers for static dir
}
HttpDispatcher.prototype.on = function(method, url, cb) {
	this.listeners[method].push({
		cb: cb,
		url: url
	});
}
HttpDispatcher.prototype.filter = function(method, url, cb) {
	this.filters[method].push({
		cb: cb,
		url: url
	});
}
HttpDispatcher.prototype.onGet = function(url, cb) {
	this.on('get', url, cb);
}	
HttpDispatcher.prototype.onPost = function(url, cb) {
	this.on('post', url, cb);
}
HttpDispatcher.prototype.onError = function(cb) {
	this.errorListener = cb;
}
HttpDispatcher.prototype.setStatic = function(folder) {
	this.on('get', new RegExp("\/"+folder), this.staticListener.bind(this));
}
HttpDispatcher.prototype.setStaticDirname = function(dirname) {
	this.staticDirname = dirname;
}
//Ekliptor> cache headers for static dir
/**
 * Set additional static headers (for caching).
 * @param headerArray [{name: "foo", value: "baa"},...]
 */
HttpDispatcher.prototype.setStaticHeaders = function(headerArray) {
    this.staticHeaders = headerArray;
}
//Ekliptor< cache headers for static dir
HttpDispatcher.prototype.beforeFilter = function(url, cb) {
	this.filter('before', url, cb);
}
HttpDispatcher.prototype.afterFilter = function(url, cb) {
	this.filter('after', url, cb);
}
HttpDispatcher.prototype.dispatch = function(req, res) {
	var url = require('url').parse(req.url, true);
	var method = req.method.toLowerCase();
	var dispatcher = this;
	var doDispatch = function() {
		var httpChain = new HttpChain();
        httpChain.extendRes(res); //Ekliptor> extend response
		var beforeFilters = this.getFilters(url.pathname, 'before');
		httpChain.addAll(beforeFilters);
		var listener = this.getListener(url.pathname, method);
		var listenerCb = listener ? listener : this.errorListener;
		httpChain.add(httpChain.getWrapped(listenerCb));
		var afterFilters = this.getFilters(url.pathname, 'after');
		httpChain.addAll(afterFilters);
		httpChain.next(req, res);
	}
	if(method == 'post') {
		var body = '';
		//> Multipart form fix
		if (typeof req.headers['content-type'] === 'string' && req.headers['content-type'].match(/^multipart\/form-data/i) !== null) {
			var form = new multiparty.Form();
			form.parse(req, function(err, fields, files) {
				req.form = form;
				req.formErr = err;
				req.formFields = fields;
				req.formFiles = files;
				doDispatch.call(dispatcher);
			});
		}
		//< Multipart form fix
		else {
			req.on('data', function (data) {
				body += data;
			});
			req.on('end', function () {
				var post = require('querystring').parse(body);
				req.body = body;
				req.params = post;
				doDispatch.call(dispatcher);
			});
		}
	} else {
		var url_parts = require('url').parse(req.url, true);
		req.params = url_parts.query;
		doDispatch.call(dispatcher);
	}
}
HttpDispatcher.prototype.staticListener =  function(req, res) {
	var url = require('url').parse(req.url, true);
	var filename = require('path').join(this.staticDirname, url.pathname);
	var errorListener = this.errorListener;
	var that = this; //Ekliptor> cache headers for static dir
	require('fs').readFile(filename, function(err, file) {
		if(err) {
			errorListener(req, res);
			return;
		}
        //Ekliptor> cache headers for static dir
        that.staticHeaders.forEach((header) => {
            res.setHeader(header.name, header.value);
		});
        //Ekliptor< cache headers for static dir
		res.writeHeader(200, {
			"Content-Type": require('mime').lookup(filename)
		});
		res.write(file, 'binary');
		res.end();
	});
}
HttpDispatcher.prototype.getListener = function(url, method) {
	for(var i = 0, listener; i<this.listeners[method].length; i++) {
		listener = this.listeners[method][i];
		if(this.urlMatches(listener.url, url)) return listener.cb;
	}
}
HttpDispatcher.prototype.getFilters = function(url, type) {
	var filters = [];
	for(var i = 0, filter; i<this.filters[type].length; i++) {
		filter = this.filters[type][i];
		if(this.urlMatches(filter.url, url)) filters.push(filter.cb);
	}
	return filters;
}
HttpDispatcher.prototype.urlMatches = function(config, url) {
	if(config instanceof RegExp) return config.test(url);
	if(util.inspect(config) == "[Function]") return config(url);
	return config == url;
}
//> Multipart form fix
/**
 * A multipart post response can hold an array for every key. This function returns POST data
 * with only the 1st element of every array (since most of the time we don't use arrays for POST data).
 * @param formFields the original POST data
 * @returns {object} a JavaScript object with key=value of the POST data
 */
HttpDispatcher.prototype.getSingleKeyPostReq = function(formFields) {
    let simpleRes = {}
	if (!formFields)
		return simpleRes;
	for (let key in formFields)
	{
		let value = formFields[key];
		if (Array.isArray(value) === true) {
			if (value.length !== 0)
				simpleRes[key] = value[0]; // take the 1st array element
			else
				simpleRes[key] = "";
		}
		else
			simpleRes[key] = value; // keep unknown data
	}
	return simpleRes;
}

/**
 * Return the parameters of this request
 * @param req
 * @param plainData default true, meaning if array data is present under a key only the 1st value will be returned
 * @returns {object}
 */
HttpDispatcher.prototype.getAnyQueryData =  function(req, plainData = true) {
	if (req.formFields) // multipart post data
		return plainData === true ? this.getSingleKeyPostReq(req.formFields) : req.formFields;
	return req.params || {}; // url-encoded get or post data
}
//< Multipart form fix

var HttpChain = function() {
	this.queue = [];
}
HttpChain.prototype.add = function(cb) {
	this.queue.push(cb);
}
HttpChain.prototype.addAll = function(cbs) {
	for(var i = 0; i<cbs.length; i++) this.add(cbs[i]);
}
HttpChain.prototype.next = function(req, res) {
	var cb = this.queue.shift();
	if(cb) cb(req, res, this);
}
HttpChain.prototype.stop = function(req, res) {
	res.end();
}
HttpChain.prototype.getWrapped = function(cb) {
	return function(req, res, chain) {
		cb(req, res);
		chain.next(req, res);
	}
}

//Ekliptor> extend response
HttpChain.prototype.extendRes = function(res) {
	res.setCacheHeaders = function (expiresMin, vary = '') {
        // TODO pass in req and set low value if logged in? (to avoid caching status html from header)
        // gmdate https://www.npmjs.com/package/phpdate-js
        // not really needed because Cache-Control max-age overrides Expires: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
        // also: new Date(Date.now() + ms).toUTCString() returns the same GMT time for this case
        if (expiresMin == 0) {
            res.setHeader('Pragma', 'no-cache')
            res.setHeader('Cache-Control', 'no-cache, private, must-revalidate, max-stale=0, post-check=0, pre-check=0, no-store')
            //res.setHeader('Expires', 'gmdate now')
            if (vary !== '')
                vary = ', ' + vary
            res.setHeader('Vary', 'Cookie' + vary)
            return
        }
        let expires = expiresMin * 60
        res.setHeader('Pragma', 'public')
        //res.setHeader('Cache-Control', 'must-revalidate, max-age=' + expires)
        res.setHeader('Cache-Control', 'public, max-age=' + expires)
        if (vary !== '') // Vary Accept-Encoding is present if compression is enabled. setHeader adds headers and doesn't override them
            res.setHeader('Vary', vary)
        //res.setHeader('Expires', 'gmdate now + expires')
    }
    res.sendStatus = function(statusCode) { // added to be compatible with ExpressJS API
        res.writeHead(statusCode, res.getHeaders());
    }
}
//Ekliptor< extend response
module.exports = new HttpDispatcher();
